# RPG Battle（仮称）要件定義書

## 0. 実行方法（ローカル実行 / MVP）
### 0.1 前提
- **Node.js + npm** が利用できること
- **MySQL または MariaDB** がローカルで起動していること

### 0.2 DB準備
- DBを作成（例: `rpg_battle`）
  - MySQL/MariaDB（例）:
    - `mysql -u root -p -e "CREATE DATABASE IF NOT EXISTS rpg_battle DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"`
- DDLを適用（テーブル作成）
  - 同梱SQL: `rpg_battle/server/sql/schema.sql`
  - MySQL/MariaDB（例）:
    - `mysql -u root -p rpg_battle < rpg_battle/server/sql/schema.sql`
  - Nodeスクリプト（例）:
    - `cd rpg_battle/server`
    - （DBにパスワードがある場合）`$env:DB_PASSWORD="YOUR_PASSWORD"`
    - `node scripts/apply-ddl.js`
- `9.3 DDL（案）` のSQLを実行してテーブル（`users`, `user_state`, `runs`）を作成

### 0.3 サーバ起動（API）
- 環境変数（`rpg_battle/server/src/db/db.ts` より）
  - `DB_HOST`（default: `127.0.0.1`）
  - `DB_PORT`（default: `3306`）
  - `DB_USER`（default: `root`）
  - `DB_PASSWORD`（default: 空）
  - `DB_NAME`（default: `rpg_battle`）
- その他（`rpg_battle/server/src/index.ts` より）
  - `PORT`（default: `3000`）
  - `SESSION_SECRET`（default: `dev_secret`）
  - `CLIENT_ORIGINS`（default: `http://localhost:5173`、カンマ区切りで複数指定可）

PowerShell例:
- `cd rpg_battle/server`
- `npm install`
- （DBにパスワードがある場合）`$env:DB_PASSWORD="YOUR_PASSWORD"`
- `npm run dev`

### 0.4 クライアント起動（画面）
- 開発時は **Viteのproxy** により `/api/*` を `http://localhost:3000` へ転送する（`rpg_battle/client/vite.config.ts`）。

PowerShell例:
- `cd rpg_battle/client`
- `npm install`
- `npm run dev`

### 0.5 動作確認の最短手順
- ブラウザでクライアントへアクセス（Viteの表示URL）
- 新規登録 → ログイン → Start → PartySelect → Battle → Menu → ゲーム終了（保存してログアウト）

## 目次
- 1. 概要
- 2. ゴール / 非ゴール
- 3. スコープ（MVP / Phase 2）
- 4. 対象ユーザー / 動作環境
- 5. システム全体像（責務分割）
- 6. 画面・UI要件（ドラクエ風）
- 7. ゲーム仕様（戦闘/階層/育成/保存/戦績）
- 8. マスタデータ（`master_data/*.json`）仕様
- 9. 永続化（DB）設計
- 10. API設計（REST + セッション）
- 11. 実装アーキテクチャ（ファイル構成 / クラス構成）
- 12. 開発フロー（破綻しない進め方）
- 13. 調整ポイント一覧（暫定値の差し替え箇所）

---

## 1. 概要
ターン制コマンドバトルを中心とした RPG ゲームシミュレーターを開発する。キャラクターを強化しながら階層型ダンジョンを進み、長期的な育成と挑戦を提供する。ログイン機能とデータ保存機能により、プレイヤーの進捗を保持し継続プレイを可能にする。

### 1.1 決定済みサマリ（MVP）
- **フロントエンド**: Vue（PC向け、レスポンシブ非対応）
- **バックエンド**: Node.js
- **DB**: MySQL または MariaDB
- **認証**: username + password
- **戦闘**: **サーバが戦闘を実行（サーバ権威）**
- **battle state**: **サーバメモリのみ**で保持（リロード復帰は要件外）
- **保存タイミング**: 全滅時 / メニューでゲーム終了時
- **全滅時の挙動**: 戦績を保存し、進捗（階層/育成/アイテム）を初期化して最初から（**ログイン状態は維持**）
- **階層進行**: 「次の戦闘」選択で +1、基本エンドレス（1〜100をデフォルト階層）
- **敵生成**: floorEnemyCost によるコスト編成（101階以降は全敵が候補）

---

## 2. ゴール / 非ゴール
### 2.1 ゴール
- ブラウザ上で、ログイン→キャラ選択→戦闘→強化→階層進行→保存/終了、のループが成立していること
- 100階までを「デフォルト階層」として遊べるバランス調整の土台があること
- 101階以降は難易度が急上昇し、101〜300階では「ほとんどのプレイヤーがゲームオーバー」になる難易度を目標とする
- 全滅時は育成状況をリセットし、再挑戦できること
- 戦績（統計）を保存し、メニューから過去記録やユーザー別ランキングを閲覧できること

### 2.2 非ゴール（MVPではやらない）
- レスポンシブ対応
- リロード復帰（戦闘状態の永続化）
- サウンド（Phase 2以降）
- セキュリティ強化（Phase 2以降）

---

## 3. スコープ（MVP / Phase 2）
### 3.1 MVP（本書の主対象）
- **実行形態**: 実行PC内にサーバを構築して動作（ローカル実行）
- **UI**: ドラクエ風（ログウィンドウ、ステータス枠、敵画像）
- **保存**: 全滅/終了時のみ
- **戦闘**: サーバで実行、battle state はサーバメモリのみ

### 3.2 Phase 2（将来拡張）
- **外部サーバでの実行**（自宅サーバ等）に対応する
  - デプロイ/運用/ネットワーク公開に伴う要件（HTTPS/セキュリティ/バックアップ等）は Phase 2 で検討

---

## 4. 対象ユーザー / 動作環境
- **想定ユーザー**: PCブラウザで遊ぶプレイヤー
- **画面サイズ**: PC画面程度（レスポンシブ非対応）

---

## 5. システム全体像（責務分割）
### 5.1 全体像（論理）
```
プレイヤー（ブラウザ）
    ↓
[ログイン画面] / [新規登録画面]
    ↓
[ゲーム本体]
  PartySelect → Battle → Menu →（次の戦闘 / 終了 / 戦績閲覧）
```

### 5.2 責務分割（MVP確定）
- **クライアント（Vue）**:
  - 画面表示、入力（ボタン/キーボード）、battle state の表示
  - 進捗のローカル保持（保存前）
  - 全滅/終了時に保存APIを呼ぶ
- **サーバ（Node.js）**:
  - 認証（セッション）
  - 進捗保存（DB）
  - 戦績保存（DB）
  - **戦闘の実行**（敵生成/行動順/ダメージ/状態異常/敵AI）
  - **battle state はメモリ保持**

### 5.3 保存タイミング（確定）
- **保存する**: 全滅時 / メニューでゲーム終了時
- **保存しない**: 階層突破時、戦闘終了時

### 5.4 中断（ゲーム終了）と再開（MVP確定）
- **中断（= メニューでゲーム終了）**:
  - 現在の進捗をDBに保存し、**ログアウト状態**でログイン画面に戻る
- **再開**:
  - 中断中のアカウントで再ログインした場合、**保存した地点から再開**する
  - battle state は保持しないため、再開地点は **戦闘中ではなく「メニュー」**を前提とする

### 5.5 Start画面（ログイン後のスタート画面）（MVP確定）
- ログイン成功後は、直ちにゲームへ入らず **Start画面**を表示する
- Start画面では **ユーザー名**を表示し、以下を選択できる:
  - **ゲームスタート**: 保存地点（`resume.screen`）に応じてゲームを開始/再開する
  - **ログアウト**: ログアウトしてログイン画面へ戻る

---

## 6. 画面・UI要件（ドラクエ風）
### 6.1 共通
- **入力**:
  - 基本はボタン形式のGUI（ドロップダウンは使用しない）
  - **キーボード操作も受付**（MVP確定: 矢印キーで選択、Enterで決定）
- **敵表示**: **敵は画像付きで表示**
- **プレイヤーキャラ表示**: パーティ編成画面やステータス欄で **キャラごとのアイコン/画像**を使用

### 6.2 演出・エフェクト（MVP）
- **バトルログ**: 画面下部にメッセージウィンドウを配置し、「〇〇の攻撃！」「△△に10のダメージ！」などの行動履歴を表示
- **ステータス表示**: 戦闘中、パーティ3人のHP/MP（および名前/Lv）を常時表示（ドラクエ風ウィンドウ）
- **ヒット演出**: 敵画像点滅 または 軽いシェイク程度
- **サウンド**: MVPでは無し

### 6.3 画面一覧（MVP）
- Login（ログイン）
- Register（新規登録）
- Start（スタート画面：ユーザー名表示＋開始/ログアウト）
- PartySelect（パーティ選択）
- Battle（戦闘）
- Menu（戦闘後メニュー）
- Stats/Ranking（戦績・ランキング）
- RunDetail（戦績詳細：スナップショット）

### 6.4 画面遷移（確定）
```
[Login]
  ├─ (新規登録へ) → [Register] → (登録成功) → [Login]
  └─ (ログイン成功)
        ↓
      [Start]
        ├─ ゲームスタート → （resume.screen に応じて分岐）
        │    ├─ resume.screen = party_select → [PartySelect]
        │    └─ resume.screen = menu → [Menu]
        └─ ログアウト → [Login]

    [PartySelect]
        ↓（決定）
      [Battle]
        ↓ (勝利)
      [Menu]
        ├─ キャラ再選択 → [PartySelect] → [Battle]
        ├─ アイテム使用 → [Menu]（同画面内で完結）
        ├─ レベルアップ → [Menu]（同画面内で完結）
        ├─ 戦績/ランキング → [Stats/Ranking]
        │                  └─ 記録クリック → [RunDetail] → [Stats/Ranking] → [Menu]
        ├─ 次の戦闘 → （floor + 1）→ [Battle]
        └─ ゲーム終了 → 保存 → ログアウト → [Login]

（全滅）[Battle] → 戦績保存 → 進捗初期化保存 → （ログイン維持）→ [Start] → [PartySelect]...
```

---

### 6.5 UIレイアウト定義（MVP）
「ドラクエ風」を再現するため、基本は **黒背景 + 白枠ウィンドウ**を組み合わせた固定レイアウトとする。

#### 6.5.1 Login（ログイン画面）
- **画面構成（中央寄せ）**:
  - タイトル: `RPG Battle`（仮）
  - 入力欄（縦並び）:
    - ユーザー名（textbox）
    - パスワード（password textbox）
  - ボタン（横並び）:
    - 「ログイン」（primary）
    - 「新規登録へ」（secondary）
  - メッセージ欄（ウィンドウ）:
    - 入力エラー、ログイン失敗、通信失敗を表示
- **入力バリデーション（MVP暫定）**:
  - ユーザー名: 3〜20文字
  - パスワード: 3〜20文字
- **キーボード（推奨）**:
  - Enter: ログイン実行
  - Tab: フォーカス移動

#### 6.5.2 Register（ユーザ登録画面）
- **画面構成（中央寄せ）**:
  - タイトル: `新規登録`
  - 入力欄（縦並び）:
    - ユーザー名
    - パスワード
    - パスワード（確認）
  - ボタン:
    - 「登録する」（primary）
    - 「ログインへ戻る」（secondary）
  - メッセージ欄:
    - 入力エラー、重複ユーザー名、通信失敗を表示
- **入力バリデーション（MVP暫定）**:
  - Loginと同じ + パスワード確認一致

#### 6.5.3 Game 共通レイアウト（PartySelect / Battle / Menu）
ゲーム中は「ドラクエ風」に、以下の領域を基本とする（固定）。
- **上部バー**:
  - 左: ユーザー名
  - 右: 現在階層（例: `FLOOR 12`）
- **中央メイン領域**: 画面ごとの主表示（パーティ選択 / 敵表示 / メニュー等）
- **下部ログ/操作領域**:
  - 左: メッセージウィンドウ（バトルログ・説明文）
  - 右: コマンドウィンドウ（ボタン群）

#### 6.5.4 PartySelect（パーティ選択）
- **目的**: 7キャラから3人選択し確定
- **中央メイン領域**:
  - 左: キャラ一覧（7キャラ、アイコン＋名前＋Lv）
  - 右: 選択枠（3枠、選択中キャラを表示）
- **下部コマンド**:
  - 「決定」（3人揃っている時のみ有効）
  - 「選択解除」（選択枠から1人外す）
  - 「ログアウト」（ログイン画面へ。未保存なので通常は確認ダイアログ）
- **キーボード（推奨）**:
  - ↑↓: 一覧選択
  - Enter: 選択/解除
  - 1/2/3: 選択枠フォーカス

#### 6.5.5 Battle（戦闘画面）
- **中央メイン領域（戦闘表示）**:
  - 上: 敵画像エリア（1〜5体を横並び。ボスは強調表示）
  - 下: 味方ステータスウィンドウ（3人分、名前/Lv/HP/MP）
- **下部ログ/操作領域**:
  - 左: バトルログ（最新が下、必要ならスクロール）
  - 右: コマンドウィンドウ
    - 行動者が味方のときのみ表示・入力可
    - コマンド: 「たたかう」「じゅもん」「どうぐ」「ぼうぎょ」
- **サブウィンドウ（必要時に出現）**:
  - じゅもん選択: スキル一覧（使用不可はグレーアウト）
  - どうぐ選択: アイテム一覧（所持0はグレーアウト）
  - 対象選択: 単体/全体に応じて対象ボタンを表示
- **入力ロック**:
  - サーバ処理中（API待ち）はコマンドを無効化し二重送信を防ぐ

#### 6.5.6 Menu（戦闘後メニュー）
- **中央メイン領域**:
  - 左: メニュー項目（縦）
    - 「レベルアップ」
    - 「キャラ再選択」
    - 「アイテム使用」
    - 「戦績/ランキング」
    - 「次の戦闘」
    - 「ゲーム終了」
  - 右: 説明/プレビュー（選択中項目の説明）
- **重要**:
  - 「ゲーム終了」選択時にのみ保存（10.5）

#### 6.5.7 Stats/Ranking（戦績・ランキング）
- **画面構成**:
  - タブ（または切替ボタン）:
    - 「自分の戦績」
    - 「ランキング」
- **自分の戦績**:
  - 一覧テーブル: `日時 / ended_reason / 最高到達階層 / 最大ダメージ`
  - 行クリック: RunDetailへ
- **ランキング**:
  - 一覧テーブル: `順位 / ユーザー名 / 最高到達階層 / 最大ダメージ`

#### 6.5.8 RunDetail（戦績詳細）
- **表示**:
  - 上部: ended_reason / 最高到達階層 / 最大ダメージ
  - 左: 全キャラクターLv一覧
  - 右: 全スキルLv一覧
- **戻る**: Stats/Rankingへ

## 7. ゲーム仕様（戦闘/階層/育成/保存/戦績）
### 7.1 認証（LoginSystem）
#### 7.1.1 新規登録
- ユーザー名＋パスワードでユーザーを作成する
- 初期状態:
  - キャラクター/スキル: 全てレベル1
  - 所持アイテム: 初期所持（8.6）
  - 階層: 1

#### 7.1.2 ログイン
- 入力されたユーザー名＋パスワードで認証する

#### 7.1.3 パスワード保存（暫定: MVP仮）
- **平文で保存**（`password` カラムにそのまま格納）
- Phase 2（外部公開）では見直す前提

### 7.2 パーティ（PartyManager）
- 7キャラ固定から3人を選択する
- 再選択できるタイミング:
  - ゲーム開始時
  - 毎階層突破時（戦闘終了後メニューから）

#### 7.2.1 キャラクター（固定7職）
- 勇者: バランスがよく様々なスキルが使える
- 戦士: 物理攻撃力と防御力が高いが、ほとんど物理攻撃しか使えない
- 魔法使い: 魔法攻撃力が高く全体魔法を使えるが、HPと防御が低い
- 僧侶: 回復中心。**戦闘中のみ使用可能な「死者蘇生」**を唯一習得
- 騎士: HP/防御が高く回復/バフが多いが攻撃力が低い
- 呪術師: 状態異常/バフが多いが攻撃力が低い
- 盗賊: speedが速く会心率高め。一部状態異常/ヒールも可能

### 7.3 戦闘（BattleSystem）
#### 7.3.1 戦闘コマンド（確定）
- たたかう（通常攻撃）: 必須
- じゅもん（スキル）: 必須
- どうぐ（アイテム）: **戦闘中も使用可能**
- ぼうぎょ: 実装する
- にげる: 実装しない

#### 7.3.2 戦闘の実行（MVP確定）
- 戦闘は **サーバが実行**する（クライアントは入力・表示）
- battle state は **サーバメモリのみ**で保持（リロード復帰なし）

#### 7.3.3 行動順（暫定: MVP仮）
**MVP確定**: 行動順は以下の式で戦闘開始時に確定し、その戦闘中は固定する。
- `initiative = speed * level`
- 並び順: `initiative` 降順
- 同値の場合: ランダム

> 注記: 「階層ごとに固定」を満たすため、同値ランダムの結果も戦闘開始時に確定し battle state に保持する。

#### 7.3.4 ダメージ/回復（暫定: MVP仮）
- 前提:
  - 物理: `currentAtk`
  - 魔法: `matk`（魔法防御は `currentDef` を共用）
  - バフ/デバフは `current*` に事前反映
- 通常攻撃（物理）:
  - `base = attacker.currentAtk - floor(defender.currentDef * 0.5)`
  - `lvl = 1 + attacker.level * 0.02`
  - `variance = randFloat(0.90, 1.10)`
  - `damage = floor(max(1, base) * lvl * variance)`
- スキル攻撃:
  - `stat = (powerType == 'magical') ? attacker.matk : attacker.currentAtk`
  - `base = stat * (power / 100) - floor(defender.currentDef * 0.5)`
  - `lvl = 1 + attacker.level * 0.02`
  - `variance = randFloat(0.90, 1.10)`
  - `damage = floor(max(1, base) * lvl * variance)`
- クリティカル:
  - `if randFloat(0, 1) < critRate` then `damage = floor(damage * critMag)`
- 命中:
  - `if randFloat(0, 1) > accuracy` then `damage = 0`（Miss）
- ぼうぎょ:
  - 防御中の対象への被ダメージを `floor(damage * 0.5)`（次の自分の行動開始まで）
- 回復スキル/アイテム:
  - `healing = power * (1 + attacker.level * 0.02) * randFloat(0.95, 1.05)`
  - クリティカルは適用しない（回復は常に成功）
- 属性:
  - MVPでは属性相性は未実装（`element` は保持のみ）

#### 7.3.5 状態異常（暫定: MVP仮）
- ターン開始:
  - DOT: `hp -= value`
  - regen: `hp = min(maxHp, hp + value)`
  - stun: 行動スキップ
  - バフ/デバフ: `current*` 再計算して反映
- ターン終了:
  - `duration -= 1`、`duration <= 0` は削除

#### 7.3.6 死者蘇生（僧侶固有）（暫定: MVP仮）
- 戦闘中のみ、`isDead = true` の対象のみ
- 復活時:
  - HP: `floor(maxHp * 0.30)`（最低1）
  - MP: 0
  - 状態異常: 全解除（`conditions = []`）
  - 行動順: 次に回ってきたタイミングから行動

### 7.4 敵生成（EnemyFactory）（暫定: MVP仮）
#### 7.4.1 ルール（確定）
- 1戦闘あたり敵は1〜5体
- `sum(effectiveCost) <= floorEnemyCost` を満たすように編成
- 101階以降は出現階層制限なし（全敵候補）
- ボスは専用データ。1ターン複数回行動などの特殊行動を許容

#### 7.4.2 暫定パラメータ（MVP仮）
- ボス階層: 10,20,...,100
- floorEnemyCost:
  - `base100(f) = 30 + f * 5 + floor(f / 10) * 10`（1〜100）
  - `base300(f) = base100(100) + (f - 100) * 12 + floor((f - 100) / 10) * 25`（101〜300）
  - `floorEnemyCost(f) = (f <= 100) ? base100(f) : (f <= 300) ? base300(f) : base300(300) + (f - 300) * 15`
- 敵実効コスト:
  - `effectiveCost = baseCost + level * 2`
- 編成アルゴリズム（概要）:
  - 候補をフィルタ → 1〜5体になるまでランダム選出（上限超過しない範囲）
  - ボス階層（1〜100）ではボスを1体確定し、残りを雑魚で埋める

### 7.5 敵AI（暫定: MVP仮）
- 優先順位:
  1. HP30%以下かつ回復スキル所持 → 回復
  2. パーティ全体HP50%以下かつ全体攻撃所持 → 全体攻撃
  3. それ以外: 通常攻撃60% / スキル40%
- 対象選択:
  - 単体: ランダム
  - 全体: 全員
  - 回復/バフ: 自己または最もHPが低い味方

### 7.6 育成（ExperienceSystem）（暫定: MVP仮）
#### 7.6.1 レベル/経験値
- レベル上限: 99
- 獲得経験値（勝利時、パーティ全員）:
  - `gainExp = floorEnemyCost(currentFloor) * 2`
  - 3人に均等配分（端数切り捨て）
- 必要経験値:
  - `nextExp(level) = floor(50 * level * level)`（Lv1→2は50）

#### 7.6.2 スキル育成
- スキルレベル上限: 10
- 使用したスキルに勝利時 `+1`（使用回数分）
- 必要スキル経験値:
  - `skillNextExp(level) = level * 3`
- unlock/prerequisite:
  - マスタJSONの `unlockLevel` / `prerequisiteIds` を満たす場合のみ使用可能

### 7.7 階層進行（確定）
- 1階層 = 1戦闘
- 「次の戦闘」で階層+1
- 1〜100: デフォルト階層
- 101〜300: 難易度急上昇
- 301〜: 300と同じ上昇率で継続（暫定）

### 7.8 保存/全滅（確定）
- 保存タイミング: 全滅時 / ゲーム終了時
- 全滅時:
  - 戦績保存
  - 進捗初期化（階層1、Lv1、初期アイテム）
- ゲーム終了時（階層突破メニューで終了）:
  - 現在の進捗をDBに保存
  - **ログアウト状態**でログイン画面に戻す
  - 次回ログイン時は **保存地点（メニュー）**から再開する

> 追加仕様（MVP確定）:
> - **全滅時はログアウトしない**（ログイン状態維持）
> - 全滅後は Start画面に戻り、ニューゲームとして再開する

### 7.9 戦績/ランキング（確定）
- 一覧表示:
  - 最高到達階層
  - 最大ダメージ
- 最大ダメージ定義:
  - **プレイヤーが敵に与えた単発最大ダメージ**
- ランキング:
  - ソート: 最高到達階層 → 最大ダメージ → 新しい記録
- クリックで詳細:
  - その記録の全キャラLv / 全スキルLv

---

## 8. マスタデータ（`master_data/*.json`）仕様
### 8.1 共通仕様（MVP確定）
- 形式: `{ "schemaVersion": 1, "data": [ ... ] }`
- `id`: snake_case
- 参照: `*Id` は `id` 文字列
- `critRate` / `accuracy` / `chance`: 0.0〜1.0
- `imageKey`: `client/src/assets/**/<imageKey>.png` に一致（拡張子除外）
- サーバ起動時にバリデーションし、異常なら起動失敗（MVP推奨）

### 8.1.1 参照整合性（MVP必須）
以下は **実装時に必ず整合**させる（不足すると戦闘や画面が破綻する）。
- `characters.json` の `initialSkillIds` / `learnableSkillIds` は `skills.json` の `id` を参照する
- `skills.json` の `conditions[].conditionId` は `conditions.json` の `id` を参照する
- `enemies.json` の `skillIds` は `skills.json` の `id` を参照する
- `items.json` の `id` は、進捗（所持アイテム）で参照する

> 注記: 本書の例に出てくる `attack_basic` / `heal_small` / `ether` / `burn` 等は、実際に各JSONに定義すること（例示IDのまま実装してOK）。

### 8.2 `characters.json`
```json
{
  "schemaVersion": 1,
  "data": [
    {
      "id": "hero",
      "name": "勇者",
      "description": "バランスがよく様々な系統のスキルが使える",
      "imageKey": "hero",
      "baseStats": { "maxHp": 100, "maxMp": 30, "atk": 15, "matk": 10, "def": 10, "speed": 10 },
      "growthPerLevel": { "maxHp": 8, "maxMp": 3, "atk": 2, "matk": 2, "def": 2, "speed": 1 },
      "initialSkillIds": ["attack_basic"],
      "learnableSkillIds": ["fireball", "heal_small"],
      "tags": ["balanced"]
    }
  ]
}
```
- ステータス算出（暫定）: `base + (level - 1) * growth`

### 8.3 `skills.json`
```json
{
  "schemaVersion": 1,
  "data": [
    {
      "id": "fireball",
      "name": "ファイアボール",
      "description": "敵単体に魔法ダメージ",
      "skillType": "attack",
      "targetType": "enemy",
      "range": "single",
      "power": 120,
      "powerType": "magical",
      "element": "fire",
      "scaling": "matk",
      "critRate": 0.05,
      "critMag": 1.5,
      "cost": 5,
      "costType": "mp",
      "accuracy": 0.95,
      "conditions": [
        { "conditionId": "burn", "chance": 0.2, "durationOverride": 2 }
      ],
      "unlockLevel": 3,
      "prerequisiteIds": [],
      "isPassive": false
    }
  ]
}
```

### 8.4 `items.json`
```json
{
  "schemaVersion": 1,
  "data": [
    {
      "id": "potion",
      "name": "ポーション",
      "description": "味方単体のHPを回復",
      "type": "potion",
      "target": "ally",
      "battleUsable": true,
      "maxStack": 99,
      "effect": { "kind": "heal_hp", "power": 30 }
    }
  ]
}
```

### 8.5 `conditions.json`
```json
{
  "schemaVersion": 1,
  "data": [
    {
      "id": "poison",
      "name": "毒",
      "conditionType": "dot",
      "stat": "hp",
      "value": 5,
      "valueType": "add",
      "duration": 3
    }
  ]
}
```

### 8.6 `enemies.json`
```json
{
  "schemaVersion": 1,
  "data": [
    {
      "id": "slime_a",
      "name": "スライム",
      "imageKey": "slime_01",
      "baseCost": 10,
      "appearMinFloor": 1,
      "appearMaxFloor": 15,
      "isBoss": false,
      "baseStats": { "maxHp": 50, "maxMp": 0, "atk": 8, "matk": 0, "def": 5, "speed": 6 },
      "growthPerLevel": { "maxHp": 5, "maxMp": 0, "atk": 1, "matk": 0, "def": 1, "speed": 1 },
      "skillIds": ["attack_basic"],
      "aiProfile": { "type": "default" }
    }
  ]
}
```
- 敵レベル（暫定）: `enemyLevel = max(1, floor(currentFloor / 2))`

### 8.7 初期所持アイテム（暫定）
- ポーション: 3
- エーテル: 1

---

## 9. 永続化（DB）設計
### 9.1 方針（MVP確定）
- 進捗は `user_state.state_json` に **1 JSONで保持（正規化しない）**

### 9.2 テーブル
- `users`
- `user_state`
- `runs`

### 9.3 DDL（案）
```sql
CREATE TABLE users (
  id BIGINT NOT NULL AUTO_INCREMENT,
  username VARCHAR(32) NOT NULL,
  password VARCHAR(255) NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  UNIQUE KEY uq_users_username (username)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE user_state (
  user_id BIGINT NOT NULL,
  current_floor INT NOT NULL DEFAULT 1,
  state_json JSON NOT NULL,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (user_id),
  CONSTRAINT fk_user_state_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE runs (
  id BIGINT NOT NULL AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  ended_reason ENUM('game_over','quit') NOT NULL,
  start_at DATETIME NULL,
  end_at DATETIME NULL,
  max_floor_reached INT NOT NULL,
  max_damage INT NOT NULL DEFAULT 0,
  run_stats_json JSON NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  KEY idx_runs_user_id_created_at (user_id, created_at),
  KEY idx_runs_rank_floor_damage (max_floor_reached, max_damage),
  CONSTRAINT fk_runs_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 9.4 ランキングクエリ（案）
```sql
SELECT
  u.id AS user_id,
  u.username,
  MAX(r.max_floor_reached) AS best_floor,
  MAX(r.max_damage) AS best_damage
FROM users u
JOIN runs r ON r.user_id = u.id
GROUP BY u.id, u.username
ORDER BY best_floor DESC, best_damage DESC, MAX(r.created_at) DESC;
```

### 9.5 `state_json` / `run_stats_json` の形式（MVP推奨）
実装を詰まらせないため、DBに入るJSONの最低限の形を定義する（拡張可）。

#### 9.5.1 `user_state.state_json`（進捗）
```json
{
  "schemaVersion": 1,
  "currentFloor": 1,
  "resume": { "screen": "menu" },
  "party": ["hero", "warrior", "priest"],
  "characters": {
    "hero": { "level": 1, "exp": 0, "hp": 100, "mp": 30 },
    "warrior": { "level": 1, "exp": 0, "hp": 120, "mp": 10 }
  },
  "skills": {
    "fireball": { "level": 1, "exp": 0 }
  },
  "items": {
    "potion": 3,
    "ether": 1
  }
}
```
- **再開地点（MVP確定）**:
  - `resume.screen` は `menu` / `party_select` / `start` を取り得る
  - `battle` はMVPでは不可（battle stateを保持しないため）
- **参照ID**: `party`/`characters` のキーは `characters.json` の `id`、`skills` のキーは `skills.json` の `id`、`items` のキーは `items.json` の `id`
- **所持数**: アイテムごとに 0〜99（8.4）
- **注意**: 戦闘状態（battle state）はここには保存しない（MVPの方針）

#### 9.5.2 `runs.run_stats_json`（戦績スナップショット）
```json
{
  "schemaVersion": 1,
  "endedReason": "quit",
  "maxFloorReached": 12,
  "maxDamage": 180,
  "characterLevels": { "hero": 12, "warrior": 10, "priest": 9 },
  "skillLevels": { "fireball": 3, "heal_small": 2 }
}
```
- RunDetail画面はこのJSONから「全キャラLv/全スキルLv」を表示できればOK

---

## 10. API設計（REST + セッション）
### 10.1 認証
- `POST /api/auth/register`
- `POST /api/auth/login`
- `POST /api/auth/logout`

### 10.2 進捗
- `GET /api/state`
- `PUT /api/state`（終了時/全滅時のみ）

### 10.3 戦績/ランキング
- `POST /api/runs`
- `GET /api/runs`
- `GET /api/ranking`

### 10.4 戦闘（サーバ権威）
- `POST /api/battle/start`
- `POST /api/battle/act`
- `GET /api/battle/:battleId`

### 10.5 保存呼び出しタイミング（確定）
- ゲーム終了:
  - `POST /api/runs`（quit）
  - `PUT /api/state`
  - `POST /api/auth/logout`
- 全滅:
  - `POST /api/runs`（game_over）
  - 進捗初期化
  - `PUT /api/state`
  - （ログイン維持のため **logoutは呼ばない**）

### 10.6 レスポンス/エラーの共通形式（MVP推奨）
クライアント実装を詰まらせないため、APIのエラー形式を統一する。

#### 10.6.1 成功レスポンス（例）
```json
{ "ok": true, "data": { } }
```

#### 10.6.2 エラーレスポンス（例）
```json
{ "ok": false, "error": { "code": "UNAUTHORIZED", "message": "login required" } }
```
- `code` の例: `BAD_REQUEST`, `UNAUTHORIZED`, `FORBIDDEN`, `NOT_FOUND`, `CONFLICT`, `INTERNAL`

### 10.7 戦闘APIの入出力（MVP推奨）
サーバ権威戦闘で詰まりやすい「進捗の持ち方」を統一するため、APIで扱う最低限の形を定義する。

- `POST /api/battle/start`（推奨入力）
  - `floor`: number（基本は `state_json.currentFloor` を送る）
  - `party`: string[]（3人、キャラID）
  - `state`: object（戦闘開始に必要な進捗スナップショット：所持アイテム数、各キャラLv/HP/MP等）
- `POST /api/battle/act`（推奨入力）
  - `battleId`, `actorId`, `action`, `target`, `payload`（skillId/itemId等）
- `BattleStartResponse/BattleActResponse`（推奨出力）
  - `battle`（battle state：敵/味方の現在HP、行動者、ログ）
  - `deltaState`（消費アイテムや獲得経験値など、進捗への差分。クライアントはローカル進捗へ適用）

#### 10.7.1 進捗の正（MVP確定）
MVPでは以下を**確定仕様**とする。
- **アイテム所持数の正はサーバ**とする
  - `POST /api/battle/act` で `payload.itemId` が指定された場合、サーバは `state.items[itemId]` を確認し、足りなければエラー（`BAD_REQUEST`）を返す
  - 成功時、サーバはアイテム消費を `deltaState` として返し、クライアントはローカル進捗へ適用する
- **スキルコスト（MP等）の正もサーバ**とする（同様に不足時はエラー）

> 注記: MVPは保存が終了/全滅時のみなので、戦闘中の進捗は「クライアントのローカル進捗 + サーバから返るdelta」で維持する設計が最も簡単。

---

## 11. 実装アーキテクチャ（ファイル構成 / クラス構成）
### 11.1 ファイル構成（推奨）
```
rpg_battle/
  client/
    src/
      assets/
        enemies/
        ui/
      components/
      pages/
      router/
      store/
      services/
      types/
  server/
    src/
      api/
      auth/
      db/
      game/
      master/
      validation/
  shared/
    types/
  master_data/
    characters.json
    skills.json
    items.json
    conditions.json
    enemies.json
  要件定義.md
  readme.md
```

### 11.2 クラス/モジュール構成（要点）
- サーバ:
  - `BattleService`, `EnemyFactory`, `TurnManager`, `DamageCalculator`, `ConditionSystem`, `EnemyAI`, `ExperienceService`
  - `BattleMemoryStore`（メモリ保持）
  - `UserRepository`, `UserStateRepository`, `RunRepository`
  - `AuthController`, `StateController`, `BattleController`, `RunController`, `RankingController`
- クライアント:
  - `ApiClient`
  - `AuthStore`, `UserStateStore`, `BattleViewStore`, `StatsStore`
  - `LoginPage`, `RegisterPage`, `PartySelectPage`, `BattlePage`, `MenuPage`, `StatsRankingPage`, `RunDetailPage`

---

## 12. 開発フロー（破綻しない進め方）
### 12.1 方針
- 縦に切って「動くもの」を早く作る（登録→戦闘→終了保存）
- UIより先にサーバ戦闘（battle/start→battle/act）を通す
- マスタJSON/進捗JSONの変更に強い設計を優先する

### 12.2 推奨実装順
1. 土台（repo構成、DB接続、セッション、マスタロード）
2. 認証/進捗（register/login/state）
3. 戦闘API（start/act + メモリ保持）
4. クライアント導線（Login→PartySelect→Battle→Menu）
5. 戦績/ランキング（runs/ranking + 詳細表示）

### 12.3 動作確認チェック
- 登録→ログイン→state取得
- battle/start→battle/actで勝敗が出る
- 全滅で戦績保存 + 進捗初期化
- 終了で戦績保存 + 進捗保存

### 12.4 ファイルごとの開発フロー（詳細）
この章は「どの順番で、どのファイルを作る/触るか」を **MVPで詰まらない順**に並べる。
（ファイル名は推奨。実際の命名は多少変更してもよいが、責務は維持する）

#### 12.4.1 フェーズ0: プロジェクト土台（最初に作る）
- **server**
  - `server/package.json`: Node/依存関係、起動スクリプト
  - `server/src/index.ts`（or `index.js`）: サーバエントリ
  - `server/src/api/router.ts`: `/api/*` のルート集約
  - `server/src/auth/session.ts`: Cookieセッション設定
  - `server/src/db/db.ts`: DB接続（MySQL/MariaDB）
  - `server/src/master/MasterDataLoader.ts`: `master_data/*.json` ロード + 参照整合性チェック
  - `server/src/validation/validate.ts`: 共通バリデーション（必須キー、型、範囲）
- **client**
  - `client/package.json`: Vue/依存関係、起動スクリプト
  - `client/src/main.ts`: エントリ
  - `client/src/router/index.ts`: 画面ルーティング（Login/Register/Start/PartySelect/Battle/Menu/Stats/RunDetail）
  - `client/src/services/ApiClient.ts`: fetchラッパ（認証/進捗/戦闘/戦績）
- **master_data**
  - `master_data/characters.json`
  - `master_data/skills.json`
  - `master_data/items.json`
  - `master_data/conditions.json`
  - `master_data/enemies.json`

> ゴール: サーバ起動でマスタJSONを検証でき、クライアントからAPI疎通できる。

#### 12.4.2 フェーズ1: DBと認証（まず“ログインできる”まで）
- **DDL適用**
  - （手順）`9.3 DDL` をDBに反映
- **server**
  - `server/src/db/UserRepository.ts`
  - `server/src/db/UserStateRepository.ts`
  - `server/src/api/AuthController.ts`（register/login/logout）
  - `server/src/api/StateController.ts`（GET/PUT /api/state）
- **client**
  - `client/src/pages/LoginPage.vue`
  - `client/src/pages/RegisterPage.vue`
  - `client/src/store/AuthStore.ts`
  - `client/src/store/UserStateStore.ts`

> ゴール: 新規登録→ログイン→`GET /api/state` が成功する。

#### 12.4.3 フェーズ2: Start画面と再開（中断復帰の土台）
- **client**
  - `client/src/pages/StartPage.vue`
    - ユーザー名表示
    - 「ゲームスタート」「ログアウト」
  - `client/src/router/index.ts`: ログイン後はStartへ遷移
  - `client/src/store/UserStateStore.ts`: `resume.screen` を見て Menu/PartySelect に遷移
- **server**
  - `server/src/api/AuthController.ts`: logout の動作確認（10.5）

> ゴール: ログイン成功→Start→（resumeに応じて）Menu or PartySelectへ遷移できる。

#### 12.4.4 フェーズ3: 戦闘ドメイン（サーバ権威戦闘を先に完成）
- **server**
  - `server/src/game/BattleMemoryStore.ts`: battle state をメモリ保持
  - `server/src/game/TurnManager.ts`: 行動順（`initiative = speed * level` + 同値ランダム）
  - `server/src/game/DamageCalculator.ts`: ダメージ/回復/防御
  - `server/src/game/ConditionSystem.ts`: 状態異常（開始/終了処理）
  - `server/src/game/EnemyFactory.ts`: floorEnemyCost制約で敵生成
  - `server/src/game/EnemyAI.ts`: 敵行動決定（暫定）
  - `server/src/game/ExperienceService.ts`: 経験値/スキル経験値の付与
  - `server/src/game/BattleService.ts`: start/act のオーケストレーション
  - `server/src/api/BattleController.ts`: `/api/battle/start` `/api/battle/act` `/api/battle/:battleId`

> ゴール: Postman等なしでも、最低限のリクエストで start→act が成立し、ログとHPが動く。

#### 12.4.5 フェーズ4: クライアント戦闘画面（入力→サーバ→表示）
- **client**
  - `client/src/pages/BattlePage.vue`
  - `client/src/components/BattleLogWindow.vue`
  - `client/src/components/PartyStatusWindow.vue`
  - `client/src/components/EnemyDisplay.vue`
  - `client/src/components/CommandPanel.vue`（攻撃/じゅもん/どうぐ/ぼうぎょ）
  - `client/src/components/TargetSelector.vue`
  - `client/src/store/BattleViewStore.ts`
  - `client/src/services/ApiClient.ts`: `battleStart/battleAct/battleGet`
  - キーボード: ↑↓で選択、Enterで決定（6.1/13）

> ゴール: Battle画面から操作でき、サーバ戦闘が進む。

#### 12.4.6 フェーズ5: Menu/PartySelect（ゲームループの完成）
- **client**
  - `client/src/pages/PartySelectPage.vue`
  - `client/src/pages/MenuPage.vue`
  - 「次の戦闘」で floor+1 → battle/start
  - 「ゲーム終了」で 10.5 の順に API 呼び出し→Loginへ
- **server**
  - `server/src/api/StateController.ts`: PUT（終了時/全滅時）を実運用で確認

> ゴール: PartySelect→Battle→Menu→次の戦闘…→終了 が一周する。

#### 12.4.7 フェーズ6: 全滅時の仕様（ログイン維持でStartへ）
- **server**
  - `server/src/game/BattleService.ts`: 全滅判定→戦績保存用データ生成→進捗初期化（7.8）
- **client**
  - 全滅時: `/api/runs` → `PUT /api/state` を実行し、**ログアウトせず** Startへ戻す（6.4/10.5）

> ゴール: 全滅したらStartへ戻り、同アカウントでニューゲーム開始できる。

#### 12.4.8 フェーズ7: 戦績/ランキング画面
- **server**
  - `server/src/db/RunRepository.ts`
  - `server/src/api/RunController.ts` / `server/src/api/RankingController.ts`
- **client**
  - `client/src/pages/StatsRankingPage.vue`
  - `client/src/pages/RunDetailPage.vue`

> ゴール: 戦績一覧/ランキング/詳細が表示できる。

---

## 13. 調整ポイント一覧（暫定値の差し替え箇所）
- キーボード操作のキー割当（MVP確定: 矢印キーで選択、Enterで決定）
- 行動順計算式（7.3.3）（MVP確定: `initiative = speed * level`）
- ダメージ/回復/防御の係数（7.3.4）
- 状態異常の効果量/適用順（7.3.5 / 8.5）
- 敵レベル式/敵AI/敵コスト/難易度曲線（7.4/7.5/8.6）
- 経験値/スキル育成曲線（7.6）

